import Anthropic from '@anthropic-ai/sdk';
import type {
  FingerprintResult,
  AiExploitProbe,
  AiResponseAnalysis,
  AiCveResult,
  Severity,
} from '../types/index.js';
import { httpGet, httpRequest } from '../utils/network.js';

let client: Anthropic | null = null;

function getClient(): Anthropic {
  if (!client) {
    const apiKey = process.env.ANTHROPIC_API_KEY;
    if (!apiKey) {
      throw new Error('ANTHROPIC_API_KEY environment variable is required for AI CVE scanning');
    }
    client = new Anthropic({ apiKey });
  }
  return client;
}

// ─── Main Entry Point ───────────────────────────────────────────

/**
 * Run the AI CVE pipeline for a single target:
 * 1. Claude identifies applicable CVEs and generates exploit probes
 * 2. Execute probes deterministically
 * 3. Claude analyzes responses to confirm vulnerability
 */
export async function runAiCveAnalysis(
  target: FingerprintResult,
  options: {
    model: string;
    safeMode: boolean;
    maxCvesPerHost: number;
    alreadyTested: Set<string>;
  }
): Promise<AiCveResult[]> {
  const results: AiCveResult[] = [];

  console.log(`[ai-cve] Asking Claude for CVEs affecting ${target.vendor} ${target.model || ''} (${target.ip}:${target.port})...`);

  // Step 1: Claude identifies CVEs and generates probes in one call
  const probes = await identifyCvesAndGenerateProbes(target, options);

  if (probes.length === 0) {
    console.log(`[ai-cve] No testable CVEs identified for ${target.ip}:${target.port}`);
    return results;
  }

  // Filter out CVEs already tested by hardcoded checks
  const newProbes = probes.filter((p) => !options.alreadyTested.has(p.cveId));
  console.log(`[ai-cve] ${newProbes.length} CVE probes to test for ${target.ip}:${target.port} (${probes.length - newProbes.length} skipped — already tested by hardcoded checks)`);

  // Step 2 + 3: For each probe, execute then analyze
  for (const probe of newProbes) {
    try {
      // Step 2: Execute the probe deterministically
      const response = await executeProbe(target, probe);

      // Step 3: Claude analyzes the response
      const analysis = await analyzeResponse(target, probe, response, options.model);

      // Post-processing: reject findings where the AI itself flagged high false positive risk
      let confirmedVulnerable = analysis.vulnerable;
      let adjustedEvidence = analysis.evidence;

      if (analysis.vulnerable && analysis.falsePositiveRisk === 'high') {
        confirmedVulnerable = false;
        adjustedEvidence = `[REJECTED — high false positive risk] ${analysis.evidence}`;
        console.log(`[ai-cve] Rejected ${probe.cveId} on ${target.ip}:${target.port} — AI flagged high false positive risk`);
      }

      if (analysis.vulnerable && analysis.falsePositiveRisk === 'medium' && analysis.confidence !== 'high') {
        confirmedVulnerable = false;
        adjustedEvidence = `[REJECTED — medium false positive risk with ${analysis.confidence} confidence] ${analysis.evidence}`;
        console.log(`[ai-cve] Rejected ${probe.cveId} on ${target.ip}:${target.port} — medium FP risk with non-high confidence`);
      }

      results.push({
        cveId: probe.cveId,
        ip: target.ip,
        port: target.port,
        vendor: target.vendor,
        title: probe.title,
        severity: probe.severity,
        cvssScore: probe.cvssScore,
        vulnerable: confirmedVulnerable,
        confidence: analysis.confidence,
        evidence: replaceTargetPlaceholders(adjustedEvidence, target),
        reasoning: replaceTargetPlaceholders(analysis.reasoning, target),
        poc: confirmedVulnerable ? replaceTargetPlaceholders(analysis.poc, target) : '',
        remediation: confirmedVulnerable ? analysis.remediation : '',
        source: 'ai',
        timestamp: new Date().toISOString(),
      });
    } catch (error) {
      console.error(`[ai-cve] Error testing ${probe.cveId} on ${target.ip}: ${(error as Error).message}`);
    }
  }

  return results;
}

// ─── Step 1: Identify CVEs + Generate Probes ─────────────────────

interface AiCveProbe extends AiExploitProbe {
  title: string;
  severity: Severity;
  cvssScore: number;
}

async function identifyCvesAndGenerateProbes(
  target: FingerprintResult,
  options: { model: string; safeMode: boolean; maxCvesPerHost: number }
): Promise<AiCveProbe[]> {
  const anthropic = getClient();

  const safetyConstraint = options.safeMode
    ? `SAFETY CONSTRAINT: Generate ONLY non-destructive, read-only detection probes.
- Only GET requests or safe POST requests that read information
- NEVER generate probes that write data, delete data, create accounts, modify configs, or execute commands
- NEVER generate actual exploit payloads — only detection probes that check IF the vulnerability exists
- The goal is DETECTION, not exploitation`
    : `Generate detection probes that confirm the vulnerability. Prefer non-destructive checks, but you may use POST/PUT if needed for detection. Do NOT generate destructive payloads.`;

  const message = await anthropic.messages.create({
    model: options.model,
    max_tokens: 8192,
    messages: [{
      role: 'user',
      content: `You are a security researcher. Based on your knowledge of CVEs and camera vulnerabilities, identify known CVEs that could affect this specific device and generate HTTP detection probes for each.

TARGET DEVICE:
- IP: ${target.ip}:${target.port}
- Vendor: ${target.vendor}
- Model: ${target.model || 'unknown'}
- Firmware: ${target.firmware || 'unknown'}
- Server Header: ${target.serverHeader || 'none'}
- Auth Type: ${target.authType}
- Protocols: ${target.protocols.join(', ')}
- Web Interface: ${target.webInterface}
- ONVIF: ${target.onvifSupported}

${safetyConstraint}

Return up to ${options.maxCvesPerHost} CVEs. For each one, provide a detection probe.

Respond with a JSON array. Each element:
{
  "cveId": "CVE-XXXX-XXXXX",
  "title": "Short description of the vulnerability",
  "severity": "critical" | "high" | "medium" | "low",
  "cvssScore": 9.8,
  "method": "GET" | "POST" | "PUT" | "OPTIONS",
  "path": "/the/endpoint/to/probe",
  "headers": {"Header-Name": "value"},
  "body": "request body if POST/PUT, omit for GET",
  "expectedVulnerablePattern": "regex pattern that indicates vulnerability in the response",
  "expectedSafePattern": "regex pattern that indicates the device is NOT vulnerable",
  "timeout": 10000
}

Requirements:
- Only include CVEs you are confident affect this vendor/device type
- The path should be the specific endpoint that this CVE targets
- The patterns should be specific enough to distinguish vulnerable from patched responses
- The expectedVulnerablePattern MUST match SPECIFIC vulnerability indicators, NOT just "endpoint exists" or "returns 200"
- The expectedSafePattern should match normal/patched device behavior so it can filter out false positives
- For command injection CVEs: the probe must attempt to trigger observable behavior (e.g., time delay, unique output), not just check if the endpoint exists
- For auth bypass CVEs: the probe must access a resource that REQUIRES authentication — do not use publicly accessible endpoints
- A GET request to a device info/capabilities endpoint that returns 200 with XML is NOT evidence of a CVE — that is normal device behavior
- Sort by severity (critical first)
- Include the real CVE ID (not made up)
- Do NOT include a CVE if you cannot design a probe that reliably distinguishes vulnerable from non-vulnerable

Respond ONLY with the JSON array, no other text.`,
    }],
  });

  const responseText = message.content
    .filter((block): block is Anthropic.TextBlock => block.type === 'text')
    .map((block) => block.text)
    .join('');

  try {
    const parsed = JSON.parse(extractJson(responseText)) as AiCveProbe[];

    // Validate and filter probes
    return parsed.filter((probe) => {
      if (!probe.cveId || !probe.path || !probe.method) return false;

      if (options.safeMode) {
        const method = probe.method.toUpperCase();
        if (method === 'DELETE' || method === 'PUT') {
          console.warn(`[ai-cve] Safe mode: rejecting ${method} probe for ${probe.cveId}`);
          return false;
        }
        if (probe.body && /rm\s|drop\s|delete\s|exec\s|system\(/i.test(probe.body)) {
          console.warn(`[ai-cve] Safe mode: rejecting dangerous payload for ${probe.cveId}`);
          return false;
        }
      }

      return true;
    }).slice(0, options.maxCvesPerHost);
  } catch {
    console.error('[ai-cve] Failed to parse CVE identification response from Claude');
    return [];
  }
}

// ─── Step 2: Deterministic Probe Execution ──────────────────────

interface ProbeResponse {
  statusCode: number;
  headers: Record<string, string>;
  body: string;
  error?: string;
}

async function executeProbe(
  target: FingerprintResult,
  probe: AiExploitProbe
): Promise<ProbeResponse> {
  const scheme = target.protocols.includes('https') ? 'https' : 'http';
  const url = `${scheme}://${target.ip}:${target.port}${probe.path}`;
  const timeout = probe.timeout || 10_000;

  try {
    let response;
    if (probe.method === 'GET' || probe.method === 'OPTIONS') {
      response = await httpGet(url, {
        timeout,
        headers: probe.headers,
      });
    } else {
      response = await httpRequest(url, probe.method, probe.body, {
        timeout,
        headers: probe.headers,
        contentType: probe.headers?.['Content-Type'] || 'application/json',
      });
    }

    const body = typeof response.data === 'string'
      ? response.data
      : JSON.stringify(response.data || '');

    return {
      statusCode: response.status,
      headers: response.headers as Record<string, string>,
      body: body.substring(0, 5000),
    };
  } catch (error) {
    return {
      statusCode: 0,
      headers: {},
      body: '',
      error: (error as Error).message,
    };
  }
}

// ─── Step 3: Response Analysis ──────────────────────────────────

async function analyzeResponse(
  target: FingerprintResult,
  probe: AiCveProbe,
  response: ProbeResponse,
  model: string
): Promise<AiResponseAnalysis> {
  const anthropic = getClient();

  const message = await anthropic.messages.create({
    model,
    max_tokens: 2048,
    messages: [{
      role: 'user',
      content: `You are a security analyst determining if a device is ACTUALLY vulnerable based on a probe response. Your job is to PREVENT false positives — only confirm real vulnerabilities.

CVE: ${probe.cveId}
Title: ${probe.title}
Severity: ${probe.severity} (CVSS ${probe.cvssScore})

PROBE SENT:
- Method: ${probe.method}
- Path: ${probe.path}
- Headers: ${JSON.stringify(probe.headers)}
${probe.body ? `- Body: ${probe.body}` : ''}

RESPONSE RECEIVED:
- Status Code: ${response.statusCode}
- Headers: ${JSON.stringify(response.headers)}
- Body (first 3000 chars): ${response.body.substring(0, 3000)}
${response.error ? `- Error: ${response.error}` : ''}

EXPECTED PATTERNS:
- Vulnerable pattern: ${probe.expectedVulnerablePattern}
- Safe pattern: ${probe.expectedSafePattern}

TARGET INFO:
- Vendor: ${target.vendor}, Model: ${target.model || 'unknown'}, Firmware: ${target.firmware || 'unknown'}

Analyze this response carefully and CRITICALLY. Consider:
1. Does the status code indicate the endpoint exists?
2. Does the response body match the vulnerable or safe pattern?
3. Are there other indicators in headers or body that confirm or deny the vulnerability?
4. Could this be a false positive (e.g., generic error page, redirect, WAF block)?
5. Is there concrete evidence of the vulnerability, or just ambiguous behavior?

CRITICAL FALSE POSITIVE RULES — You MUST follow these:
- An endpoint returning HTTP 200 DOES NOT by itself prove a vulnerability. Many camera endpoints are publicly accessible by design.
- An endpoint returning expected data (XML, JSON, device info) DOES NOT prove it is vulnerable — it may just be normal device behavior.
- CVE exploitation requires SPECIFIC vulnerable behavior, not just "endpoint exists and responds."
- If the probe is a simple GET and the response is normal device data, this is NOT evidence of a CVE — it is evidence the device is working normally.
- For command injection CVEs: there must be evidence of command execution in the response (e.g., output of injected command, unusual errors showing injection reached a shell).
- For auth bypass CVEs: the probe must access data that SHOULD require authentication but was returned WITHOUT valid credentials. A publicly accessible status/capabilities page is NOT an auth bypass.
- For information disclosure CVEs: the response must contain SENSITIVE data (credentials, private keys, internal configs) not just general device metadata.
- When in doubt, mark as NOT vulnerable with falsePositiveRisk "medium" or "high".
- Only set falsePositiveRisk to "low" when you have DEFINITIVE, UNAMBIGUOUS evidence.

BE EXTREMELY CONSERVATIVE. The cost of a false positive is much higher than a false negative. Only mark as vulnerable if the evidence is indisputable.

Respond with a single JSON object:
{
  "cveId": "${probe.cveId}",
  "vulnerable": true | false,
  "confidence": "high" | "medium" | "low",
  "evidence": "Specific evidence from the response that confirms or denies vulnerability",
  "reasoning": "Step-by-step analysis of why you reached this conclusion",
  "poc": "If vulnerable: a curl command or similar that reproduces the issue. If not vulnerable: empty string",
  "remediation": "If vulnerable: specific fix recommendation. If not: empty string",
  "falsePositiveRisk": "low" | "medium" | "high"
}

Respond ONLY with the JSON object, no other text.`,
    }],
  });

  const responseText = message.content
    .filter((block): block is Anthropic.TextBlock => block.type === 'text')
    .map((block) => block.text)
    .join('');

  try {
    return JSON.parse(extractJson(responseText)) as AiResponseAnalysis;
  } catch {
    // Fallback: regex-based analysis
    let matchesVuln = false;
    let matchesSafe = false;

    try {
      const vulnPattern = new RegExp(probe.expectedVulnerablePattern, 'i');
      matchesVuln = vulnPattern.test(response.body);
    } catch { /* Invalid regex from AI, treat as no match */ }

    try {
      const safePattern = new RegExp(probe.expectedSafePattern, 'i');
      matchesSafe = safePattern.test(response.body);
    } catch { /* Invalid regex from AI, treat as no match */ }

    return {
      cveId: probe.cveId,
      vulnerable: matchesVuln && !matchesSafe,
      confidence: 'low',
      evidence: `Regex match: vuln=${matchesVuln}, safe=${matchesSafe}, status=${response.statusCode}`,
      reasoning: 'AI analysis failed, fell back to regex pattern matching',
      poc: matchesVuln && !matchesSafe
        ? `curl "${target.protocols.includes('https') ? 'https' : 'http'}://${target.ip}:${target.port}${probe.path}"`
        : '',
      remediation: matchesVuln && !matchesSafe
        ? 'Update firmware to the latest version from the manufacturer.'
        : '',
      falsePositiveRisk: 'high',
    };
  }
}

// ─── Helpers ────────────────────────────────────────────────────

function replaceTargetPlaceholders(text: string, target: FingerprintResult): string {
  if (!text) return text;
  const scheme = target.protocols.includes('https') ? 'https' : 'http';
  return text
    .replace(/<target_ip>/gi, target.ip)
    .replace(/<target_port>/gi, String(target.port))
    .replace(/<ip>/gi, target.ip)
    .replace(/<port>/gi, String(target.port))
    .replace(/\btarget_ip\b/gi, target.ip)
    .replace(/\btarget_port\b/gi, String(target.port))
    .replace(/\{target_ip\}/gi, target.ip)
    .replace(/\{target_port\}/gi, String(target.port))
    .replace(/\{ip\}/gi, target.ip)
    .replace(/\{port\}/gi, String(target.port))
    .replace(/TARGET_IP/g, target.ip)
    .replace(/TARGET_PORT/g, String(target.port))
    .replace(/\bexample\.com\b/gi, `${target.ip}:${target.port}`)
    .replace(/http:\/\/IP_ADDRESS/gi, `${scheme}://${target.ip}:${target.port}`)
    .replace(/https:\/\/IP_ADDRESS/gi, `${scheme}://${target.ip}:${target.port}`)
    .replace(/\bIP_ADDRESS\b/g, target.ip);
}

function extractJson(text: string): string {
  const fenceMatch = text.match(/```(?:json)?\s*([\s\S]*?)```/);
  if (fenceMatch) return fenceMatch[1].trim();

  const jsonMatch = text.match(/(\[[\s\S]*\]|\{[\s\S]*\})(?:\s*$)/);
  if (jsonMatch) return jsonMatch[1];

  const firstBrace = text.indexOf('{');
  const firstBracket = text.indexOf('[');
  const start = firstBrace >= 0 && (firstBracket < 0 || firstBrace < firstBracket)
    ? firstBrace : firstBracket;
  if (start >= 0) return text.substring(start).trim();

  return text.trim();
}
