import Anthropic from '@anthropic-ai/sdk';
import type {
  FingerprintResult,
  AiExploitProbe,
  AiResponseAnalysis,
  AiCveResult,
  Severity,
} from '../types/index.js';
import { httpGet, httpRequest } from '../utils/network.js';

let client: Anthropic | null = null;

function getClient(): Anthropic {
  if (!client) {
    const apiKey = process.env.ANTHROPIC_API_KEY;
    if (!apiKey) {
      throw new Error('ANTHROPIC_API_KEY environment variable is required for AI CVE scanning');
    }
    client = new Anthropic({ apiKey });
  }
  return client;
}

// ─── Main Entry Point ───────────────────────────────────────────

/**
 * Run the AI CVE pipeline for a single target:
 * 1. Claude identifies applicable CVEs and generates exploit probes
 * 2. Execute probes deterministically
 * 3. Claude analyzes responses to confirm vulnerability
 */
export async function runAiCveAnalysis(
  target: FingerprintResult,
  options: {
    model: string;
    safeMode: boolean;
    maxCvesPerHost: number;
    alreadyTested: Set<string>;
  }
): Promise<AiCveResult[]> {
  const results: AiCveResult[] = [];

  console.log(`[ai-cve] Asking Claude for CVEs affecting ${target.vendor} ${target.model || ''} (${target.ip}:${target.port})...`);

  // Step 1: Claude identifies CVEs and generates probes in one call
  const probes = await identifyCvesAndGenerateProbes(target, options);

  if (probes.length === 0) {
    console.log(`[ai-cve] No testable CVEs identified for ${target.ip}:${target.port}`);
    return results;
  }

  // Filter out CVEs already tested by hardcoded checks
  const newProbes = probes.filter((p) => !options.alreadyTested.has(p.cveId));
  console.log(`[ai-cve] ${newProbes.length} CVE probes to test for ${target.ip}:${target.port} (${probes.length - newProbes.length} skipped — already tested by hardcoded checks)`);

  // Step 2 + 3: For each probe, execute then analyze
  for (const probe of newProbes) {
    try {
      // Step 2: Execute the probe deterministically
      const response = await executeProbe(target, probe);

      // Step 3: Claude analyzes the response
      const analysis = await analyzeResponse(target, probe, response, options.model);

      results.push({
        cveId: probe.cveId,
        ip: target.ip,
        port: target.port,
        vendor: target.vendor,
        title: probe.title,
        severity: probe.severity,
        cvssScore: probe.cvssScore,
        vulnerable: analysis.vulnerable,
        confidence: analysis.confidence,
        evidence: analysis.evidence,
        reasoning: analysis.reasoning,
        poc: analysis.poc,
        remediation: analysis.remediation,
        source: 'ai',
        timestamp: new Date().toISOString(),
      });
    } catch (error) {
      console.error(`[ai-cve] Error testing ${probe.cveId} on ${target.ip}: ${(error as Error).message}`);
    }
  }

  return results;
}

// ─── Step 1: Identify CVEs + Generate Probes ─────────────────────

interface AiCveProbe extends AiExploitProbe {
  title: string;
  severity: Severity;
  cvssScore: number;
}

async function identifyCvesAndGenerateProbes(
  target: FingerprintResult,
  options: { model: string; safeMode: boolean; maxCvesPerHost: number }
): Promise<AiCveProbe[]> {
  const anthropic = getClient();

  const safetyConstraint = options.safeMode
    ? `SAFETY CONSTRAINT: Generate ONLY non-destructive, read-only detection probes.
- Only GET requests or safe POST requests that read information
- NEVER generate probes that write data, delete data, create accounts, modify configs, or execute commands
- NEVER generate actual exploit payloads — only detection probes that check IF the vulnerability exists
- The goal is DETECTION, not exploitation`
    : `Generate detection probes that confirm the vulnerability. Prefer non-destructive checks, but you may use POST/PUT if needed for detection. Do NOT generate destructive payloads.`;

  const message = await anthropic.messages.create({
    model: options.model,
    max_tokens: 8192,
    messages: [{
      role: 'user',
      content: `You are a security researcher. Based on your knowledge of CVEs and camera vulnerabilities, identify known CVEs that could affect this specific device and generate HTTP detection probes for each.

TARGET DEVICE:
- IP: ${target.ip}:${target.port}
- Vendor: ${target.vendor}
- Model: ${target.model || 'unknown'}
- Firmware: ${target.firmware || 'unknown'}
- Server Header: ${target.serverHeader || 'none'}
- Auth Type: ${target.authType}
- Protocols: ${target.protocols.join(', ')}
- Web Interface: ${target.webInterface}
- ONVIF: ${target.onvifSupported}

${safetyConstraint}

Return up to ${options.maxCvesPerHost} CVEs. For each one, provide a detection probe.

Respond with a JSON array. Each element:
{
  "cveId": "CVE-XXXX-XXXXX",
  "title": "Short description of the vulnerability",
  "severity": "critical" | "high" | "medium" | "low",
  "cvssScore": 9.8,
  "method": "GET" | "POST" | "PUT" | "OPTIONS",
  "path": "/the/endpoint/to/probe",
  "headers": {"Header-Name": "value"},
  "body": "request body if POST/PUT, omit for GET",
  "expectedVulnerablePattern": "regex pattern that indicates vulnerability in the response",
  "expectedSafePattern": "regex pattern that indicates the device is NOT vulnerable",
  "timeout": 10000
}

Requirements:
- Only include CVEs you are confident affect this vendor/device type
- The path should be the specific endpoint that this CVE targets
- The patterns should be specific enough to distinguish vulnerable from patched responses
- Sort by severity (critical first)
- Include the real CVE ID (not made up)

Respond ONLY with the JSON array, no other text.`,
    }],
  });

  const responseText = message.content
    .filter((block): block is Anthropic.TextBlock => block.type === 'text')
    .map((block) => block.text)
    .join('');

  try {
    const parsed = JSON.parse(extractJson(responseText)) as AiCveProbe[];

    // Validate and filter probes
    return parsed.filter((probe) => {
      if (!probe.cveId || !probe.path || !probe.method) return false;

      if (options.safeMode) {
        const method = probe.method.toUpperCase();
        if (method === 'DELETE' || method === 'PUT') {
          console.warn(`[ai-cve] Safe mode: rejecting ${method} probe for ${probe.cveId}`);
          return false;
        }
        if (probe.body && /rm\s|drop\s|delete\s|exec\s|system\(/i.test(probe.body)) {
          console.warn(`[ai-cve] Safe mode: rejecting dangerous payload for ${probe.cveId}`);
          return false;
        }
      }

      return true;
    }).slice(0, options.maxCvesPerHost);
  } catch {
    console.error('[ai-cve] Failed to parse CVE identification response from Claude');
    return [];
  }
}

// ─── Step 2: Deterministic Probe Execution ──────────────────────

interface ProbeResponse {
  statusCode: number;
  headers: Record<string, string>;
  body: string;
  error?: string;
}

async function executeProbe(
  target: FingerprintResult,
  probe: AiExploitProbe
): Promise<ProbeResponse> {
  const scheme = target.protocols.includes('https') ? 'https' : 'http';
  const url = `${scheme}://${target.ip}:${target.port}${probe.path}`;
  const timeout = probe.timeout || 10_000;

  try {
    let response;
    if (probe.method === 'GET' || probe.method === 'OPTIONS') {
      response = await httpGet(url, {
        timeout,
        headers: probe.headers,
      });
    } else {
      response = await httpRequest(url, probe.method, probe.body, {
        timeout,
        headers: probe.headers,
        contentType: probe.headers?.['Content-Type'] || 'application/json',
      });
    }

    const body = typeof response.data === 'string'
      ? response.data
      : JSON.stringify(response.data || '');

    return {
      statusCode: response.status,
      headers: response.headers as Record<string, string>,
      body: body.substring(0, 5000),
    };
  } catch (error) {
    return {
      statusCode: 0,
      headers: {},
      body: '',
      error: (error as Error).message,
    };
  }
}

// ─── Step 3: Response Analysis ──────────────────────────────────

async function analyzeResponse(
  target: FingerprintResult,
  probe: AiCveProbe,
  response: ProbeResponse,
  model: string
): Promise<AiResponseAnalysis> {
  const anthropic = getClient();

  const message = await anthropic.messages.create({
    model,
    max_tokens: 2048,
    messages: [{
      role: 'user',
      content: `You are a security analyst determining if a device is vulnerable based on a probe response.

CVE: ${probe.cveId}
Title: ${probe.title}
Severity: ${probe.severity} (CVSS ${probe.cvssScore})

PROBE SENT:
- Method: ${probe.method}
- Path: ${probe.path}
- Headers: ${JSON.stringify(probe.headers)}
${probe.body ? `- Body: ${probe.body}` : ''}

RESPONSE RECEIVED:
- Status Code: ${response.statusCode}
- Headers: ${JSON.stringify(response.headers)}
- Body (first 3000 chars): ${response.body.substring(0, 3000)}
${response.error ? `- Error: ${response.error}` : ''}

EXPECTED PATTERNS:
- Vulnerable pattern: ${probe.expectedVulnerablePattern}
- Safe pattern: ${probe.expectedSafePattern}

TARGET INFO:
- Vendor: ${target.vendor}, Model: ${target.model || 'unknown'}, Firmware: ${target.firmware || 'unknown'}

Analyze this response carefully. Consider:
1. Does the status code indicate the endpoint exists?
2. Does the response body match the vulnerable or safe pattern?
3. Are there other indicators in headers or body that confirm or deny the vulnerability?
4. Could this be a false positive (e.g., generic error page, redirect, WAF block)?
5. Is there concrete evidence of the vulnerability, or just ambiguous behavior?

BE CONSERVATIVE. Only mark as vulnerable if there is clear evidence. Ambiguous responses should be marked not vulnerable with medium falsePositiveRisk.

Respond with a single JSON object:
{
  "cveId": "${probe.cveId}",
  "vulnerable": true | false,
  "confidence": "high" | "medium" | "low",
  "evidence": "Specific evidence from the response that confirms or denies vulnerability",
  "reasoning": "Step-by-step analysis of why you reached this conclusion",
  "poc": "If vulnerable: a curl command or similar that reproduces the issue. If not vulnerable: empty string",
  "remediation": "If vulnerable: specific fix recommendation. If not: empty string",
  "falsePositiveRisk": "low" | "medium" | "high"
}

Respond ONLY with the JSON object, no other text.`,
    }],
  });

  const responseText = message.content
    .filter((block): block is Anthropic.TextBlock => block.type === 'text')
    .map((block) => block.text)
    .join('');

  try {
    return JSON.parse(extractJson(responseText)) as AiResponseAnalysis;
  } catch {
    // Fallback: regex-based analysis
    let matchesVuln = false;
    let matchesSafe = false;

    try {
      const vulnPattern = new RegExp(probe.expectedVulnerablePattern, 'i');
      matchesVuln = vulnPattern.test(response.body);
    } catch { /* Invalid regex from AI, treat as no match */ }

    try {
      const safePattern = new RegExp(probe.expectedSafePattern, 'i');
      matchesSafe = safePattern.test(response.body);
    } catch { /* Invalid regex from AI, treat as no match */ }

    return {
      cveId: probe.cveId,
      vulnerable: matchesVuln && !matchesSafe,
      confidence: 'low',
      evidence: `Regex match: vuln=${matchesVuln}, safe=${matchesSafe}, status=${response.statusCode}`,
      reasoning: 'AI analysis failed, fell back to regex pattern matching',
      poc: matchesVuln && !matchesSafe
        ? `curl "${target.protocols.includes('https') ? 'https' : 'http'}://${target.ip}:${target.port}${probe.path}"`
        : '',
      remediation: matchesVuln && !matchesSafe
        ? 'Update firmware to the latest version from the manufacturer.'
        : '',
      falsePositiveRisk: 'high',
    };
  }
}

// ─── Helpers ────────────────────────────────────────────────────

function extractJson(text: string): string {
  const fenceMatch = text.match(/```(?:json)?\s*([\s\S]*?)```/);
  if (fenceMatch) return fenceMatch[1].trim();

  const jsonMatch = text.match(/(\[[\s\S]*\]|\{[\s\S]*\})(?:\s*$)/);
  if (jsonMatch) return jsonMatch[1];

  const firstBrace = text.indexOf('{');
  const firstBracket = text.indexOf('[');
  const start = firstBrace >= 0 && (firstBracket < 0 || firstBrace < firstBracket)
    ? firstBrace : firstBracket;
  if (start >= 0) return text.substring(start).trim();

  return text.trim();
}
