import { promises as fs } from 'node:fs';
import path from 'node:path';
import type {
  FingerprintResult,
  CveTestResult,
  CveModuleResult,
  AiCveResult,
  VeilcamsConfig,
  CveCategory,
} from '../types/index.js';
import { getCveChecksForVendor } from '../cve-db/index.js';
import { runAiCveAnalysis } from '../ai/index.js';
import { parallelLimit } from '../utils/concurrency.js';

/**
 * Phase 3b: CVE Scanner
 *
 * Two-layer approach:
 * 1. Hardcoded checks run first (fast, zero-cost, 13 known CVEs)
 * 2. AI engine runs second (Claude identifies CVEs from its training data and generates probes)
 *
 * Results from both layers are merged and deduplicated.
 */
export async function runCveScanner(
  targets: FingerprintResult[],
  config: VeilcamsConfig,
  outputDir: string
): Promise<CveModuleResult> {
  const startTime = Date.now();
  const allResults: CveTestResult[] = [];
  const allAiResults: AiCveResult[] = [];

  if (!config.cve_testing.enabled) {
    return {
      results: [],
      totalChecks: 0,
      vulnerabilitiesFound: 0,
      criticalCount: 0,
      highCount: 0,
      durationMs: Date.now() - startTime,
    };
  }

  const enabledCategories = new Set(config.cve_testing.categories);
  const concurrency = config.rate_limiting?.max_concurrent_hosts ?? 10;

  // ── Layer 1: Hardcoded Checks (fast) ──────────────────────────

  console.log(`[cve-scanner] Running hardcoded checks on ${targets.length} hosts...`);

  const hardcodedTasks = targets.map((target) => async () => {
    const checks = getCveChecksForVendor(target.vendor);
    const filteredChecks = checks.filter((check) => {
      return matchesCategory(check.cveId, check.title, enabledCategories);
    });

    for (const check of filteredChecks) {
      try {
        const result = await check.check(target);
        allResults.push(result);
      } catch (error) {
        allResults.push({
          cveId: check.cveId,
          ip: target.ip,
          port: target.port,
          vendor: target.vendor,
          title: check.title,
          severity: check.severity,
          vulnerable: false,
          evidence: `Check threw error: ${(error as Error).message}`,
          poc: '',
          remediation: '',
          timestamp: new Date().toISOString(),
        });
      }
    }
  });

  await parallelLimit(hardcodedTasks, concurrency);

  const hardcodedVulns = allResults.filter((r) => r.vulnerable).length;
  console.log(`[cve-scanner] Hardcoded checks complete: ${hardcodedVulns} vulnerabilities from ${allResults.length} checks`);

  // ── Layer 2: AI CVE Engine (comprehensive) ────────────────────

  if (config.cve_testing.ai_enabled) {
    if (!process.env.ANTHROPIC_API_KEY) {
      console.warn('[cve-scanner] AI CVE scanning enabled but ANTHROPIC_API_KEY not set — skipping AI layer');
    } else {
      console.log(`[cve-scanner] Starting AI CVE analysis on ${targets.length} hosts (model: ${config.cve_testing.ai_model})...`);

      // Run AI analysis with lower concurrency to manage API rate limits
      const aiConcurrency = Math.min(concurrency, 3);
      const aiTasks = targets.map((target) => async () => {
        try {
          // Collect CVE IDs already tested by hardcoded checks FOR THIS HOST
          const alreadyTestedForHost = new Set(
            allResults
              .filter((r) => r.ip === target.ip && r.port === target.port)
              .map((r) => r.cveId)
          );

          const aiResults = await runAiCveAnalysis(target, {
            model: config.cve_testing.ai_model,
            safeMode: config.cve_testing.safe_mode,
            maxCvesPerHost: config.cve_testing.ai_max_cves_per_host,
            alreadyTested: alreadyTestedForHost,
          });

          allAiResults.push(...aiResults);
        } catch (error) {
          console.error(`[cve-scanner] AI analysis failed for ${target.ip}:${target.port}: ${(error as Error).message}`);
        }
      });

      await parallelLimit(aiTasks, aiConcurrency);

      const aiVulns = allAiResults.filter((r) => r.vulnerable).length;
      console.log(`[cve-scanner] AI analysis complete: ${aiVulns} vulnerabilities from ${allAiResults.length} additional checks`);
    }
  }

  // ── Merge Results ─────────────────────────────────────────────

  // Convert AI results to standard CveTestResult format for the total count
  const aiAsStandard: CveTestResult[] = allAiResults.map((r) => ({
    cveId: r.cveId,
    ip: r.ip,
    port: r.port,
    vendor: r.vendor,
    title: r.title,
    severity: r.severity,
    vulnerable: r.vulnerable,
    evidence: r.evidence,
    poc: r.poc,
    remediation: r.remediation,
    timestamp: r.timestamp,
  }));

  const combinedResults = [...allResults, ...aiAsStandard];
  const allVulnerable = combinedResults.filter((r) => r.vulnerable);

  const moduleResult: CveModuleResult = {
    results: combinedResults,
    totalChecks: combinedResults.length,
    vulnerabilitiesFound: allVulnerable.length,
    criticalCount: allVulnerable.filter((r) => r.severity === 'critical').length,
    highCount: allVulnerable.filter((r) => r.severity === 'high').length,
    durationMs: Date.now() - startTime,
    aiResults: allAiResults.length > 0 ? allAiResults : undefined,
  };

  // Save deliverable
  const deliverablePath = path.join(outputDir, 'deliverables', 'cve_results.json');
  await fs.mkdir(path.dirname(deliverablePath), { recursive: true });
  await fs.writeFile(deliverablePath, JSON.stringify(moduleResult, null, 2));

  return moduleResult;
}

/**
 * Map CVE checks to user-configured categories.
 */
function matchesCategory(
  cveId: string,
  title: string,
  enabled: Set<CveCategory>
): boolean {
  if (enabled.size === 0) return true;

  const titleLower = title.toLowerCase();
  const cveIdLower = cveId.toLowerCase();

  if (enabled.has('auth_bypass')) {
    if (/auth|bypass|login|credential|session/i.test(titleLower)) return true;
  }
  if (enabled.has('info_disclosure')) {
    if (/disclos|expos|leak|config|info|snapshot|header/i.test(titleLower)) return true;
  }
  if (enabled.has('command_injection')) {
    if (/inject|command|rce|execut/i.test(titleLower)) return true;
  }
  if (enabled.has('path_traversal')) {
    if (/travers|path|directory|lfi/i.test(titleLower)) return true;
  }
  if (enabled.has('buffer_overflow')) {
    if (/overflow|buffer|memory|crash/i.test(titleLower)) return true;
  }

  if (cveIdLower.startsWith('generic')) return true;

  return false;
}
